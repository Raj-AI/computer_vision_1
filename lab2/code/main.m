%% Computer Vision 1 
% Lab 2: Filters
% Authors: Dana Kianfar - Jose Gallego

%% Exercise 2.1

im1 = imread('../Images/image2.jpeg');

% Box filters

box_sizes = [1, 2, 3, 4];
n_box = length(box_sizes);
box_results = {n_box};

subplot(1, n_box + 1, 1)
imshow(im1)
title('Original')

for i = 1:n_box
    box_results{i} = denoise(rgb2gray(im1), 'box', box_sizes(i));
    subplot(1, n_box + 1, i+1)
    imshow(box_results{i})
    title(strcat('K=' , num2str(2*i+1)))
end

% Median filters

figure

median_sizes = [1, 2, 3];
n_median = length(median_sizes);
median_results = {n_median};

subplot(1, n_median + 1, 1)
imshow(im1)
title('Original')

for i = 1:n_median
    median_results{i} = denoise(rgb2gray(im1), 'median', median_sizes(i));
    subplot(1, n_median + 1, i+1)
    imshow(median_results{i})
    title(strcat('K=' , num2str(2*i+1)))
end

% In this case, box performs better due to the properties of the noise
% present in image2.jpeg. The noise is more likely to be generated by
% Gaussian process, which is suited for the assumptions of a box kernel:
% pixel values should be spatially correlated, and the noise is stationary,
% so adding the sorrounding pixels will have 0 mean. On the other hand, 
% median filtering is more suited for handling noise in the form of outlier
% values, like 'salt and pepper' noise.

%% Exercise 2.2

input = imread('../Images/input.png');
reference = imread('../Images/reference.png');
out = myHistMatching(input, reference);